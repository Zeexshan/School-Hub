

# Backend Implementation Guidance: Authentication & Database Integration

## Context & Current State Assessment

The application foundation exists, but the backend layer requires completion to enable authentication functionality. Specifically:

- **Database Connection Layer**: Needs proper MongoDB Atlas integration
- **Data Models**: Currently using in-memory storage instead of persistent Mongoose schemas
- **API Routes**: Authentication endpoints are not yet implemented
- **Session Management**: JWT handling for stateless authentication needs to be established

---

## Implementation Priority: Backend Authentication System

Focus exclusively on completing the **server-side functionality** needed for user login and data persistence. The frontend is complete and should not be modified at this stage.

---

## Step 1: Database Connection Architecture

**File to Address**: `server/db.ts`

**Objective**: Establish a reliable connection to MongoDB Atlas that:
- Reads the connection string from environment variables (`process.env.MONGODB_URI`)
- Uses Mongoose as the ODM (Object-Document Mapper)
- Exports a reusable connection instance
- Handles connection errors gracefully
- Confirms successful connection on server startup

**Design Considerations**:
- The connection should be initialized once when the server starts
- Implement proper error handling for connection failures
- Consider connection pooling for production readiness
- Log connection status for debugging purposes

---

## Step 2: Persistent Data Models

**File to Address**: `server/storage.ts`

**Current Problem**: The file uses `MemStorage`, which loses all data when the server restarts—unacceptable for a production system.

**Required Transformation**:

### Remove In-Memory Storage
- Eliminate the `MemStorage` class entirely
- Transition to Mongoose-based persistence

### Define Mongoose Schemas
Create schema definitions for the core entities:
- **User**: Authentication credentials, role, profile information
- **Student**: Academic and personal details linked to User accounts
- **Class**: Dynamic class structure with sections
- **Attendance**: Daily attendance records by student, class, and date
- **Assignment**: Teacher-created tasks with deadlines and class associations
- **Submission**: Student work submissions linked to assignments
- **Fee**: Payment records and balances per student

### Implement the Storage Interface
- The existing `IStorage` interface defines the contract your storage layer must fulfill
- Rewrite the implementation to use Mongoose models instead of in-memory objects
- Ensure these critical methods work correctly:
  - `getUser(email)`: Retrieve a user by email for login validation
  - `createUser(userData)`: Create new user accounts with hashed passwords
  - All other methods defined in the interface must interact with MongoDB

**Key Architectural Points**:
- Use Mongoose's built-in validation features
- Hash passwords before storing (never store plain text)
- Maintain relationships between entities (e.g., Student → User, Attendance → Student)
- Return Promises or use async/await consistently

---

## Step 3: Authentication API Routes

**File to Address**: `server/routes.ts`

**Current Problem**: The file is empty—no endpoints exist for login or registration.

**Required Endpoints**:

### Login Route (`POST /api/login`)
**Purpose**: Authenticate users and issue JWT tokens

**Flow**:
1. Accept email and password from request body
2. Use the storage interface to retrieve the user by email
3. Verify the password (compare hashed values)
4. If valid, generate a JWT token containing user ID and role
5. Return the token and user profile to the client
6. If invalid, return an appropriate error response (401 Unauthorized)

**Security Considerations**:
- Never return password hashes to the client
- Use proper HTTP status codes
- Implement rate limiting (optional but recommended)

### Registration Route (`POST /api/register`)
**Purpose**: Create initial Admin account or allow controlled user creation

**Flow**:
1. Accept user details (name, email, password, role) from request body
2. Validate that the email is not already in use
3. Hash the password before storage
4. Use the storage interface to create the user
5. Return success confirmation

**Access Control Note**:
For the initial setup, this route can be open to create the first Admin account. After that, you may want to protect it so only Admins can create additional users.

### Session/JWT Handling
**Token Generation**:
- Use a JWT library (e.g., `jsonwebtoken`)
- Sign tokens with a secret key from `process.env.JWT_SECRET`
- Include user ID and role in the token payload
- Set a reasonable expiration time (e.g., 7 days)

**Token Verification Middleware** (for future protected routes):
- Create a middleware function that extracts the JWT from request headers
- Verify the token's signature
- Attach the decoded user information to the request object
- Allow the request to proceed if valid, otherwise return 401
Ensure cors is enabled on the express app or router so the frontend (running on a different port/view) can successfully hit these API endpoints without blocking.

---

## Step 4: Environment Configuration

**Required Secrets**:
The application needs these environment variables to function:

1. **`MONGODB_URI`**: Your MongoDB Atlas connection string
   - Format: `mongodb+srv://username:password@cluster.mongodb.net/dbname`
   - If not set, the server should fail to start with a clear error message

2. **`JWT_SECRET`**: Secret key for signing JWT tokens
   - Use a strong, random string (e.g., 32+ characters)
   - Never commit this to version control

**Implementation Approach**:
- Check for these environment variables when the server initializes
- If missing, provide clear instructions on where to set them (e.g., Replit Secrets tab)
- Consider providing a `.env.example` file with placeholder values for documentation

---

## Focus & Scope

**What to Implement**:
- ✅ Complete `server/db.ts` with MongoDB connection
- ✅ Rewrite `server/storage.ts` with Mongoose models and IStorage implementation
- ✅ Implement `server/routes.ts` with login and registration endpoints
- ✅ JWT generation and verification logic
- ✅ Environment variable validation

**What NOT to Touch**:
- ❌ Frontend components (React files in `/client`)
- ❌ UI styling or design
- ❌ Any existing client-side code

**Success Validation**:
When complete, a user should be able to:
1. Start the server without errors (assuming environment variables are set)
2. Make a POST request to `/api/register` and create an account
3. Make a POST request to `/api/login` with valid credentials and receive a JWT token
4. Have that user account persist even after server restart (data in MongoDB)

---

**Proceed with implementing these three server files to enable functional authentication.**